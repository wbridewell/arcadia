(ns
  ^{:doc
    "Provides an environment for processing a video or image, which might correspond
     to one trial of an experiment. The stimulus runs until a video ends, a max
     number of environmental actions are taken, or a max number of cycles is reached,
     and the environment generates messages and data describing the actions taken.

     A variety of parameters can be used to customize performance of the environment,
     for example adding some number of :buffer-frames (blank images) at the beginning
     of the stimulus or specifying that all actions should be ignored until
     :minimum-cycles-before-action have passed."}
  arcadia.simulator.environment.stimulus-player
  (:import javax.swing.JFrame)
  (:require
   [arcadia.simulator.environment.core :refer [Environment info step render reset close]]
   [arcadia.simulator.environment.video-player :as video-player]
   [arcadia.simulator.environment.static-image :as static-image]
   [arcadia.utility [opencv :as cv] [parameters :as p] [image :as img]]))

(def ^:private jframe (atom nil))

(def ^:parameter previous-state "If a previously initialized environment is provided
  here, we will use that instead of creating a new one." nil)

(def ^:parameter file-path "path for a file (video or image), to be played" nil)

(def ^:parameter max-actions "After this many environmental actions have been
  performed, proceed to the next stimulus." 1)
(def ^:parameter max-cycles "After this many cycles have been passed, proceed to
  the next stimulus." nil)
(def ^:parameter replay-final-video-frame? "If this is true, then when an input video
  ends the environment will keep replaying the final frame of the video until
  another stopping condition is met (based on max-actions or max-cycles)." false)

(def ^:parameter buffer-frames "Include this many frames of a blank screen before
  a stimulus" 0)

(def ^:parameter minimum-cycles-before-action "If this parameter has a number
  value, then for each stimulus, ignore any environmental actions until the cycle
  count has hit at least this number" nil)

(def ^:parameter increment "amount of time that passes between each cycle"
  0.025)

(def ^:parameter viewing-width "The width of the stimulus corresponds to this many
  degrees of visual angle, if a number is specified." nil)

(def ^:parameter skip-frames "Skip this many frames at the beginning of each video"
  0)

(defn- make-blank-display
  "Produces a display that is simply a black rectangle."
  [width height]
  (cv/zeros [width height] cv/CV_8UC3))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Code for accessing and working with environment information

(defn- subenv-method
  "Calls the specified function on the sub environment."
  [env funct & args]
  (apply funct (-> env :state deref :subenv) args))

#_{:clj-kondo/ignore [:unused-private-var]}
(defn- subenv-info
  "Returns the value for the specified key in the sub environment's info."
  [env info-key]
  (-> env :state deref :subenv info info-key))

(defn- state-val
  "Returns the value for the specified key in the state hashmap."
  [env state-key]
  (-> env :state deref state-key))

(defn- update-state!
  "Updates the state hashmap. Optional arguments are alternating keys and values."
  [env & args]
  (apply swap! (cons (:state env) (cons assoc args))))

(defn- get-current-image
  "Gets the current input from the sub environment, or substitutes a different
  image if appropriate. Returns either {:image image :location location}, if
  the sub environment has provided a location, or else just {:image image}"
  [env params]
  (if (<= (state-val env :buffer-count) (-> env :params :buffer-frames))
    {:image
     (make-blank-display (-> env info :width) (-> env info :height))
     :location (:location (subenv-method env render "opencv-matrix" false))}
    (subenv-method env render "opencv-matrix" false)))

(defn- new-state
  "Initializes the state hashmap for the environment."
  [subenv params]
  {:subenv subenv
   :finished? false
   :cycle -1
   :buffer-count 0
   :actions []
   :height (int (-> subenv info :height))
   :width (int (-> subenv info :width))})


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Support for reading and writing to data files

(defn- prepare-data
  "Put together a hash-map describing what happened for a particular stimulus, once
   we are done processing it. data is a vector of information describing the stimulus,
   pulled from a data file. response and counter are the environmental action
   generated by the model to end the stimulus, and the number of cycles it took
   for the action to be generated."
  [env params]
  (let [responses (state-val env :actions)
        counter (dec (state-val env :cycle))
        num-responses (or (:max-actions params) 0)
        responses (if (zero? num-responses)
                    nil
                    (concat responses
                            (repeat (- num-responses (count responses)) nil)))
        response-headers
        (cond
          (= num-responses 1) [:response]
          (> num-responses 1) (map #(keyword (str "response-" %))
                                   (range 1 (+ 1 num-responses)))
          :else nil)]
    (zipmap (cons :cycles
                    response-headers)
            (cons counter responses))))

(defn- initiate-sub-environment
  "Create a sub environment for playing the stimulus with file name fname."
  [env-args fname]
  (let [extension (apply str (take-last 3 fname))]
    (cond
      (#{"mp4" "mpg" "m4v" "mov"} extension)
      (video-player/configure (assoc env-args :video-path fname))
      (#{"png" "jpg"} extension)
      (static-image/configure (assoc env-args :image-path fname))
      :else
      (throw (Exception. (str "No environment defined for file type " extension "."))))))

(defn- get-message
  "Returns a {:message message :increment-message-count? increment?} hash-map,
   where message describes the environmental actions that have been taken and
   increment? is true if this is our first message for the current stimulus."
  [env new-action finished?]
  (let [actions (state-val env :actions)]
    (cond
      new-action
      {:message (apply str (interleave (repeat (count actions) "  ") actions))
       :increment-message-count? (= (count actions) 1)}

      (and finished? (empty? actions))
      {:message " " :increment-message-count? true}

      :else nil)))

(defrecord StimulusPlayer [state params]
  Environment

  (info [env]
        {:dimensions [:height :width]
         :height (state-val env :height)
         :width (state-val env :width)
         :viewing-width (:viewing-width params)
         :increment (:increment params)
         :render-modes ["human" "buffered-image"]
         :finished? (state-val env :finished?)
         :file-path (:file-path params)
         :actions :any})

  ;; Take a step through the environment. The exact behavior of taking a step
  ;; will vary, depending on the sub environment (are we processing a static
  ;; image or a video?).
  (step [env actions]
        (update-state! env :buffer-count (inc (state-val env :buffer-count)))
        (update-state! env :cycle (inc (state-val env :cycle)))

        ;;If we aren't finished or in the pre-stimulus buffer, process the next
        ;;frame of the stimulus.
        (if (and (not (state-val env :finished?))
                 (> (state-val env :buffer-count) (:buffer-frames params)))
          (let [advanced? (subenv-method env step actions)
                new-action
                (when (and (seq actions) (number? (:max-actions params))
                           (pos? (:max-actions params))
                           (or (nil? (:minimum-cycles-before-action params))
                               (>= (state-val env :cycle)
                                   (:minimum-cycles-before-action params))))
                  (first actions))]

            ;;If there were any environmental actions on this cycle, save one.
            (when new-action
              (update-state! env :actions (conj (state-val env :actions)
                                                new-action)))

            ;;If we're done with the stimulus, because we've
            ;;exceeded the max actions, we've exceeded the max cycles, or the
            ;;stimulus failed to progress (i.e., the video ended), then submit
            ;;the appropriate data and message.
            (if (or (and new-action
                         (>= (count (state-val env :actions))
                             (:max-actions params)))
                    (and (:max-cycles params)
                         (> (state-val env :cycle) (:max-cycles params)))
                    (not (or advanced? (:replay-final-video-frame? params))))
              (let [data (prepare-data env params)]

                (update-state! env :finished? true)
                (assoc (get-message env new-action true) :done? true :data data))
              (assoc (get-message env new-action false) :done? false)))
          {:done? (state-val env :finished?)}))

  (reset [env] ;;Not quite correct at present
         (subenv-method env reset))

  ;; Draw for human consumption or get a Java BufferedImage.
  ;; render returns its results in key-value pairs
  (render [env mode close]
          (case mode
            "human"
            (img/display-image! (if @jframe @jframe
                                    (reset! jframe (JFrame. "MultiStimuli Environment")))
                                (get-current-image env params))

            "buffered-image"
            (update (get-current-image env params) :image img/mat-to-bufferedimage)

            "opencv-matrix"
            (get-current-image env params)

            "numpy-array"
            (subenv-method env render "numpy-array" false)

            "gpu-matrix"
            (subenv-method env render "gpu-matrix" false)))

  (close [env]
         (subenv-method env close))

  ;; no randomness
  (seed [env seed-value] nil))

(defmethod print-method StimulusPlayer [env ^java.io.Writer w]
  (.write w (format "StimulusPlayer%s"
                    (-> env info (select-keys [:width :height :finished?])))))

(defn configure
  "Sets up the environment. env-args should be a map that includes, at least,
  the directory :directory-path."
  [env-args]
  (let [params (p/merge-parameters env-args)]
    (or (:previous-state params)
        (let [file-path (:file-path params)
              subenv (initiate-sub-environment env-args file-path)]
          (->StimulusPlayer
           (atom (new-state subenv params))
           params)))))
