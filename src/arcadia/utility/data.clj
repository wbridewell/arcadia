(ns
  ^{:doc "Support for saving data from a model run to an output file."}
  arcadia.utility.data
  (:require [clojure.data.csv :as csv]
            [arcadia.architecture.registry :as reg]
            [arcadia.simulator.environment.core :as env]
            (arcadia.utility [general :as g]
                             [parameters :as parameters])
            [clojure.java.io :as io]
            [clojure.walk :as clojure.walk]))

(def ^:parameter directory "directory to which data will be saved" "data")

(def ^:parameter output-file "name of the file to be saved" nil)

(def ^:parameter input-file "path and name for an input file that will provide data
  to be included in the output-file, one row of input per row of output" nil)

(def ^:parameter previous-state
  "If this is non-nil, we want to continue saving output to an existing file, rather
   than restarting from scratch." nil)

(def ^:parameter every-cycle?
  "Should we save results on every cycle? If not, we will save results only when
   the environment produces output." false)

(def ^:parameter output "List of [key element] pairs, where each key is a column header
  (in the form of a keyword) for data that will appear in the output. The
  element may be either (a) a constant that will appear identically in every row
  of the output or (b) an output-fn (created with o#) that will be resolved to
  determine the value that appears in each row of data. The output-fn will be called
  on an output-map, a hash-map whose keys include:
  :focus, :content, :cycle, :registry, :file-path
  :previous-output-map (The output map from the previous cycle)
  and all the keys for previous output items, including items appearing earlier
  on this list, as well as any output generated by the environment."
  nil)

(def ^:parameter initial-output "This parameter operates the same as the output
  parameter, except that the elements will appear in the leftmost columns of the
  resulting dastafile, whereas output specifies element that will appear in the
  rightmost columns. Any data provided by the environment will appear in the middle."
  nil)

(def ^:parameter separator "What character separates entries in the output-file?"
  \,)

(defn- output-fn?
  "Returns true if element is an output-fn."
  [element]
  (-> element meta :output-function?))

(defn- parse-string
  "Interprets a string as a number or Boolean value if possible."
  [s]
  (cond
    (re-find #"^-?\d+\.?\d*$" s)
    (read-string s)
    (or (= s "True") (= s "true"))
    true
    (or (= s "False") (= s "false"))
    false
    :else
    s))

(defn- get-input
  "Reads in data from a datafile and returns it as a list of vectors, where each
  vector corresponds to one row in the file"
  [params]
  (when-let [path (:input-file params)]
    (with-open [rdr (io/reader path)]
      (let [input (doall (csv/read-csv rdr :separator (:separator params)))]
        {:headers (first input)
         :values (map #(map parse-string %) (rest input))}))))

(defn- append-csv
  "Takes a vector and writes it to a line in a file as a csv. Appends to what is
  already in the csv unless reset? is true."
  [filename data & {:keys [separator reset?]
     :or {separator \, reset? false}}]
  (spit filename
        (with-out-str
         (clojure.data.csv/write-csv *out* (vector data) :separator separator))
        :append (not reset?)))

(defn- setup-output-file
  "Makes a new csv file to which output will be written. Writes the headers to
  the file. These includes the headers for any keys in the env-data hash-map and
  any columns in the :input-file if one is provided, as well as headers for the
  :initial-output and :output found in the params."
  [{params :params :as state} env-data]
  (let [output-file (or (:output-file params) (str (g/date+time-string) ".csv"))
        path (str (:directory params) "/" output-file)
        {input :values input-headers :headers} (get-input params)
        env-data-headers (keys env-data)]
    (g/make-directories-for-path path)
    (append-csv path
                (vec (concat (map #(name (first %)) (:initial-output params))
                             (map name env-data-headers)
                             input-headers
                             (map #(name (first %)) (:output params))))
                :separator (:separator params) :reset? true)
    (assoc state :env-data-headers env-data-headers :path path :started? true
           :input-headers (map keyword input-headers) :input input)))

(defn- write-to-output-file
  "Adds a new line to the csv output file describing a model's behavior on the
  most recent stimulus.
  UPDATE and ADD BACK IN READING FROM A FILE
  data is a vector of information describing the stimulus,
  pulled from a data file. response and counter are the environmental action
  generated by the model to end the stimulus, and the number of cycles it took
  for the action to begenerated. previous-output-map is a hashmap describing the
  model's behavior on the previous stimulus."
  [{params :params previous-output-map :previous-output-map path :path
    env-data-headers :env-data-headers input :input input-headers :input-headers
    :as state}
   env-data registry]
  ;We have to build an output-map so that we can resolve any output-fns
  ;specified in params. We compute these iteratively, so that a later
  ;output's value can depend on an earlier one's.

  (loop [output-map
         {:registry registry :cycle (reg/cycle-num registry) :focus (reg/focus registry)
          :content (reg/content registry) :previous-output-map previous-output-map
          :file-path (-> registry reg/env env/info :file-path)}
         output (concat (:initial-output params)
                        (map #(vector % (get env-data %)) env-data-headers)
                        (map vector input-headers (first input))
                        (:output params))
         resolved-output nil]
    (if (seq output)
      (let [[k elem] (first output)]
        (if (output-fn? elem)
          (let [resolved-elem (elem output-map)]
            (recur (assoc output-map k resolved-elem) (rest output)
                   (cons resolved-elem resolved-output)))
          (recur (assoc output-map k elem) (rest output)
                 (cons elem resolved-output))))
      (do
        (append-csv path (-> resolved-output reverse vec)
                    :separator (:separator params))
        (assoc state :input (rest input) :previous-output-map
               (dissoc output-map :previous-output-map))))))

(defn start
  "Set up the data structure that handles recording data to a file."
  [parameters]
  (let [params (parameters/merge-parameters parameters)]
    (or (:previous-state params)
        {:params params :started? false})))

(defn save
  "Save data to an output file."
  [env-data registry {params :params :as state}]
  (if (or env-data (:every-cycle? params))
    (-> state
        (cond-> (not (:started? state)) (setup-output-file env-data))
        (write-to-output-file env-data registry))
    state))

(defn add-single-initial-output
  "Adds a new [key value] pair to the :initial-output parameter of a data-state
   which was previously initialized by calling start. If that key is already present
   in the initial output, then instead replaces the old value with the new value."
  [data-state [ky val :as new-item]]
  (loop [prior-items nil
         items (-> data-state :params :initial-output)]
    (cond
      (empty? items)
      (if (:started? data-state)
        (throw (Exception.
                "Cannot add a new column to the data state's :initial-output after
                writing to a file has begun."))
        (assoc-in data-state [:params :initial-output]
                  (reverse (cons new-item prior-items))))

      (= (-> items first first) ky)
      (assoc-in data-state [:params :initial-output]
                (concat (reverse prior-items) (list new-item) (rest items)))

      :else
      (recur (cons (first items) prior-items) (rest items)))))

(defn add-initial-output
  "Similar to add-initial-output, but allows a list of new output items to be added
   together."
  [data-state initial-output-items]
  (reduce #(add-single-initial-output %1 %2) data-state initial-output-items))

(defmacro output-fn
  "This macro should be used in place of #() to define an anonymous information
  function. Output functions are used in the :output key of the a model run's
  data-parameters to extract information from ARCADIA's state for saving as data.
  They are always single-arity functions that take a hash-map of the form
  {:focus focus, :content content, :cycle cycle, :registry registry,
  :previous-output-map previous-output-map}, with additional keys for any previous items
  being saved as data.

  As with #(), use the symbol % to represent the argument."
  [body]
  (let [vname (gensym)]
    `(with-meta (fn [~vname]
                  ~(clojure.walk/postwalk-replace {'% vname} body))
                ~(assoc (meta &form) :output-function? true
                        :ns *ns* :file *file*))))

(def #^{:macro true} o#
  "shorthand for output-fn macro"
  #'output-fn)
