(ns arcadia.models.display-demo
  (:require (arcadia.utility [attention-strategy :as att]
                             [descriptors :as d]
                             [display :refer [i# nth-value remember-previous progression]]
                             [general :as g]
                             [model :as model]
                             [image :as img]
                             [objects :as obj]
                             [opencv :as cv])
            [arcadia.utility.geometry :as geo]
            [arcadia.architecture.registry :refer [get-sensor]]
            clojure.java.io
            arcadia.models.core))

;; For this task, we want to allow objects to double or half in
;; size when two circles intersect or stop intersecting.  Let's
;; actually make it 1.5, which means one object is equal to the
;; other * 2.5.
(def ^:dynamic *mot-size-similarity-threshold* 1.5)

;; And here's the size similarity comparison
(defn- size-comparator [obj1 obj2]
  (obj/similar-size-contours? obj1 obj2
                              :threshold  *mot-size-similarity-threshold*))

;;For comparing doubles
(def ^:private close-number-thresh 0.01)

(def ^:private lut
  "look-up table for colorizing images before displaying" (img/make-colormap-RYBG))

(defn- image-format-fn
  "Formats images before displaying them. Specially converts 32F images such that
   instead of ranging from -1 to 1, they range from 0 to 255."
  [src]
  (if (and (cv/mat-type src)
           (= (cv/depth src) cv/CV_32F))
    (-> src (cv/add 1.0) (cv/convert-to cv/CV_8U :alpha 127.49)
        (cv/cvt-color cv/COLOR_GRAY2BGR) (cv/apply-lookup-table! lut))
    src))

#_{:clj-kondo/ignore [:unused-private-var]}
(defn- corresponding-crowding-fixation
  "Returns a highlighter.crowding fixation to the same location as the
  highlighter.maintenance fixation."
  [focus content]
  (when (d/element-matches? focus :name "fixation" :reason "maintenance")
    (first (filter #(obj/same-region? % focus content)
                   (d/filter-elements content :name "fixation" :reason "crowding")))))

(defn- detect-collision
  "Model-specific function for determining if an object has undergone a collision.
  old and new the object's region before and after the possible collision.
  Trajectory-data is additional information generated by the highlighter.maintenance.
  This function uses changes in size to detect collisions."
  [old new trajectory-data]
  (let [old-area (geo/area old)
        new-area (geo/area new)]
    (and (> new-area old-area)
         (or (not (obj/similar-size-areas? old-area new-area))
             (and (:min-area trajectory-data)
                  (not (obj/similar-size-areas?
                        new-area (:min-area trajectory-data))))))))

(defn- detect-collision-end
  "Model-specific function for determining if an object has finished a collision.
  old and new the object's region before and after the possible collision.
  Trajectory-data is additional information generated by the highlighter.maintenance.
  This function uses changes in size to detect collisions."
  [old new trajectory-data]
  (let [old-area (geo/area old)
        new-area (geo/area new)]
    (and (< new-area old-area)
         (not (obj/similar-size-areas? old-area new-area))
         (:min-area trajectory-data)
         (obj/similar-size-areas?
          new-area (:min-area trajectory-data)))))

#_{:clj-kondo/ignore [:unused-private-var]}
(defn- sorter [s]
  (sort-by #(cond (= (:reason (:arguments %)) "color") 10
                  (= (:reason (:arguments %)) "memory") 8
                  :else 5)
           >
           s))

#_{:clj-kondo/ignore [:unused-private-var]}
(defn- crowding-fixations [fixations]
  (sort-by #(:threat-distance (:arguments %)) <
           (filter #(= (:reason (:arguments %)) "crowding")
                   fixations)))

#_{:clj-kondo/ignore [:unused-private-var]}
(defn- top-crowding-fixations [fixations]
  (let [crowding-fixations
        (sort-by #(:threat-distance (:arguments %)) <
                 (filter #(= (:reason (:arguments %)) "crowding")
                         fixations))

        min-dist (:threat-distance (:arguments (first crowding-fixations)))]

    (if min-dist
      (filter #(g/near-equal? (:threat-distance (:arguments %)) min-dist close-number-thresh)
              crowding-fixations)
      crowding-fixations)))

;; Looks for a crowding fixation that is being actively maintained
;; OR
;; If a maintenance fixation says the target in question is undergoing a collision
;; event, stay on that.
(defn- ongoing-maintenance-fixation [maintenance-fixation collision-fixation most-crowded
                                     crowding-fixations content]
  (and maintenance-fixation
       (or collision-fixation
;;            (-> maintenance-fixation :arguments :calculating-delta-queue?)
           (obj/same-region? maintenance-fixation most-crowded content)
           (first (filter #(obj/same-region? % maintenance-fixation content)
                          crowding-fixations)))
       maintenance-fixation))

;; Always allow other crowded regions to interrupt maintenance fixations.
#_{:clj-kondo/ignore [:unused-private-var]}
(defn- ongoing-maintenance-fixation-or-interruption
  [maintenance-fixation collision-fixation most-crowded
   crowding-fixations content]
  (or (and maintenance-fixation (not collision-fixation)
           (first (filter #(not (obj/same-region? % maintenance-fixation content))
                          crowding-fixations)))
      (and maintenance-fixation
           (or collision-fixation
               ;;            (-> maintenance-fixation :arguments :calculating-delta-queue?)
               (obj/same-region? maintenance-fixation most-crowded content)
               (first (filter #(obj/same-region? % maintenance-fixation content)
                              crowding-fixations)))
           maintenance-fixation)))


(defn select-focus [expected]
  (let [fixations (d/filter-elements expected :name "fixation")
        crowding-fixations (d/filter-elements fixations :reason "crowding")]
    (or (d/first-element expected :name "gaze" :saccading? true)
        (d/first-element expected :type "action")
        (d/first-element expected :name "object" :type "instance" :world nil)
        (d/first-element expected :name "saccade")

        ;; fixations
        (d/rand-element (att/remove-object-fixations fixations expected) :reason "color")
        (d/first-element fixations :reason "gaze")
        (d/rand-element fixations :reason "color")

        (ongoing-maintenance-fixation
          (d/first-element fixations :reason "maintenance")
          (or (d/first-element fixations :reason "collision")
              (d/first-element fixations :reason "post-collision"))
          (d/first-element crowding-fixations :reason "crowding" :most-crowded? true)
          (d/filter-elements crowding-fixations :reason "crowding" :crowded? true)
          expected)

        (d/first-element crowding-fixations :reason "crowding" :most-crowded? true)
        (d/rand-element fixations :reason "memory")
        (g/rand-if-any fixations)
        ;; end fixations

        (g/rand-if-any (seq expected)))))

#_{:clj-kondo/ignore [:unresolved-symbol]}
(defn sensor-setup []
  (model/setup
   (model/add stable-viewpoint)))

(def ^:private colors [nil :red :cyan :magenta :orange :green :blue])

#_{:clj-kondo/ignore [:unresolved-symbol]}
(defn component-setup []
  (model/setup
   (model/add image-segmenter {:sensor (get-sensor :stable-viewpoint)})
   (model/add object-file-binder)
   (model/add button-pusher)
   (model/add vstm {:diff-size-comparator size-comparator})
   (model/add object-locator {:sensor (get-sensor :stable-viewpoint)
                              :use-hats? true})

   (model/add saccade-requester {:sensor (get-sensor :stable-viewpoint)})
   (model/add smooth-pursuit {:sensor (get-sensor :stable-viewpoint)})
   (model/add highlighter.gaze-target)
   (model/add highlighter.maintenance {:detect-collision detect-collision
                                       :detect-collision-end detect-collision-end
                                       :min-delta-queue-count 2})

   (model/add
    display.fixations
    {:x 0 :y 20 :image-scale 0.5 :display-name "Visual Processing"
     :image-format-fn image-format-fn :sensor (get-sensor :stable-viewpoint)
     :precision 2
     :panels
     [["Fixations" nil
      :glyphs
      [[(i# (-> % :content (d/filter-elements :name "object-location")))
        :glyph-value (i# (-> % :glyph :arguments :slot))
        :glyph-region (i# (-> % :glyph :arguments :region))
        :y-offset -50
        :text-size 1.2 :bold? true
        :color (nth-value colors (i# (-> % :glyph :arguments :slot))
                          :gray)]
       [(i# (-> % :content (d/filter-elements :name "fixation")))
        :glyph-value (i# (-> % :glyph :arguments :threat-distance))
        :glyph-region (i# (-> % :glyph (obj/get-region (:content %))))
        :text-size 1.2 :y-offset -10 :color :green]]]
      ["Object Location Map"
       (i# (-> % :content (d/first-element :name "object-location-map")
               :arguments :data))
       :elements [[(i# (:panel %))]]
       :copy-image? false :initial-glyphs nil]]})

   (model/add
    display.objects
    {:x 1050 :y 450 :sensor (get-sensor :stable-viewpoint)
     :elements
     [["slot" (i# (-> % :panel :arguments :slot))
       :color (nth-value colors (i# (:element %)))]]})

   (model/add
    display.status
    {:x 1050 :y 150
     :elements
     [["Object Fixations" :center? true :element-spacing 20 :bold? true
       :text-size 1.1]
      ["Red"
       (remember-previous
        (i# (if (-> % :focus (d/element-matches? :name "object" :color "red"))
              (inc (:previous %))
              (:previous %)))
        0) :caption-color :red :caption-bold? true]
      ["Gray"
       (remember-previous
        (i# (if (-> % :focus (d/element-matches? :name "object" :color nil))
              (inc (:previous %))
              (:previous %)))
        0) :caption-color :gray :caption-bold? true]
      [" " :center? true :text-background :black :text-size 0.8]
      [(progression "Seeking Targets"
                    [[(i# (-> % :focus (d/element-matches? :name "object" :color nil)))
                      "Tracking Targets"]
                     [(i# (-> % :focus (d/element-matches? :name "object" :color "blue")))
                      "Responding"]])
       :center? true :text-size 1.05 :bold? true :italic? true]]})

      (model/add
       display.scratchpad
       {:x 1500 :y 20
        :sensor (get-sensor :stable-viewpoint) :image-format-fn image-format-fn
        :elements
        [[(i# (-> % :element :arguments :slot))
          (i# (-> % :content (d/filter-elements :name "object" :world "vstm")
                  (->> (sort-by #(-> % :arguments :slot str)))))]
         [(i# (-> % :element :arguments :slot))
          (i# (-> % :content (d/filter-elements :name "object-location")
                  (->> (sort-by #(-> % :arguments :slot str)))))
          :collapsed? true]
         [(i# (-> % :element :arguments :slot))
          (i# (-> % :content (d/filter-elements :name "object" :world "vstm")
                  (->> (sort-by #(-> % :arguments :slot str)))))
          :element-value (i# (-> % :element :arguments :image))
          :image-scale nil]]})

   (model/add display.controls {:x 0 :y 600})
   (model/add display.environment-messages {:x 1050 :y 20})

   (model/add highlighter.color
              {:sensor (get-sensor :stable-viewpoint)
               :excluded-colors #{"black" "gray"}})
   (model/add highlighter.crowding)
   (model/add new-object-guess-recorder {:color "blue"})))

(defn example-run
  ([]
   (example-run nil false))
  ([max-cycles]
   (example-run max-cycles false))
  ([max-cycles record?]
   ;; use resolve to avoid circular dependencies for the example run
   ((resolve 'arcadia.core/startup)
    'arcadia.models.display-demo 'arcadia.simulator.environment.stimulus-player
    {:file-path (.getPath (clojure.java.io/resource
                            "test-files/MOT_Extrap_2Targets.mp4"))
     :viewing-width 15.375
     :max-actions 2}
    max-cycles
    :record? record?)))
